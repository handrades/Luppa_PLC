import React from 'react';
import { render, screen{{#if (eq type 'form')}}, fireEvent, waitFor{{/if}} } from '@testing-library/react';
import '@testing-library/jest-dom';
{{#if (eq type 'context')}}
import { {{pascalCase name}}, {{pascalCase name}}Provider, use{{pascalCase name}} } from './{{pascalCase name}}';
{{else}}
import { {{pascalCase name}} } from './{{pascalCase name}}';
{{/if}}

describe('{{pascalCase name}}', () => {
  it('renders without crashing', () => {
    render(<{{pascalCase name}} />);
    expect(screen.getByTestId('{{dashCase name}}')).toBeInTheDocument();
  });

  it('applies custom className', () => {
    const customClass = 'custom-class';
    render(<{{pascalCase name}} className={customClass} />);
    expect(screen.getByTestId('{{dashCase name}}')).toHaveClass(customClass);
  });

  {{#if (eq type 'form')}}
  it('handles form submission', async () => {
    const mockSubmit = jest.fn();
    render(<{{pascalCase name}} onSubmit={mockSubmit} />);
    
    // Use test ID for more reliable button selection
    const submitButton = screen.getByTestId('{{dashCase name}}').querySelector('.{{dashCase name}}__submit-button') ||
                         screen.getByRole('button', { name: /submit/i });
    
    expect(submitButton).toBeInTheDocument();
    fireEvent.click(submitButton);
    
    await waitFor(() => {
      expect(mockSubmit).toHaveBeenCalled();
    });
  });

  it('validates form before submission', async () => {
    const mockSubmit = jest.fn();
    render(<{{pascalCase name}} onSubmit={mockSubmit} />);
    
    const submitButton = screen.getByTestId('{{dashCase name}}').querySelector('.{{dashCase name}}__submit-button') ||
                         screen.getByRole('button', { name: /submit/i });
    
    // Submit form without filling required fields
    fireEvent.click(submitButton);
    
    // Check that validation error appears
    await waitFor(() => {
      expect(screen.getByRole('alert')).toBeInTheDocument();
    });
    
    // Ensure form was not submitted due to validation errors
    expect(mockSubmit).not.toHaveBeenCalled();
  });
  {{/if}}

  {{#if (eq type 'context')}}
  it('provides context value', () => {
    const TestComponent = () => {
      const context = use{{pascalCase name}}();
      
      // Dynamically handle different context return structures
      let displayValue = 'default';
      
      if (typeof context === 'string') {
        displayValue = context;
      } else if (typeof context === 'object' && context !== null) {
        // Check common context patterns
        displayValue = context.value ?? context.state ?? context.data ?? JSON.stringify(context);
      }
      
      return <div data-testid="context-value">{displayValue}</div>;
    };

    // Test with different provider prop patterns
    const providerProps = {};
    
    // Check if provider accepts initialValue (current pattern)
    if (typeof {{pascalCase name}}Provider === 'function') {
      // Try common provider prop patterns
      const testProps = { initialValue: 'test', value: 'test', defaultValue: 'test' };
      Object.assign(providerProps, testProps);
    }

    render(
      <{{pascalCase name}}Provider {...providerProps}>
        <TestComponent />
      </{{pascalCase name}}Provider>
    );

    // Verify context is provided (flexible assertion)
    const contextElement = screen.getByTestId('context-value');
    expect(contextElement).toBeInTheDocument();
    
    // Verify some content is rendered (not empty)
    expect(contextElement.textContent).toBeTruthy();
  });
  {{/if}}
});